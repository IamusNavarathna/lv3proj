
function climit(cur, lower, upper)
    if(cur < lower)
        cur = upper
    elif(cur > upper)
        cur = lower
    end
    
    return cur
end

function arraysum(y): return reduce( {a,b => a+b}, y, 0 )

function ReadIniFileAsDict(fn)
    buf = VFS.GetFileAsBuf(fn)
    if not buf
        > "ReadIniFileAsDict: '", fn, "' not found"
        return nil
    end
    
    bb = ByteBuf(buf, true) // for more processing comfort, we wrap a ByteBuf around the MemBuf
    ss = StringStream(bb.readString()) // and read one string from it (which, for text files, is the entire file)
    // this is needed so the config parser will not append a newline char to config values if the original data are in windows CRLF encoding
    ss.setEncoding(getSystemEncoding(), SYSTEM_DETECT)
    cp = ConfParser()
    try
        cp.read(ss) // can fail if there is a parsing error
    catch in err
        > 'ReadIniFileAsDict("', fn, '") ERROR:'
        > err
        return nil
    end
    
    d = [ => ]
    root = cp.getDictionary() // no section
    if len(root): d[""] = root
    
    for s in cp.getSections()
        sect = cp.getDictionary(s)
        if len(sect): d[s] = sect
    end
    
    return d
end

class Array2D(w, h, arr)
    _w = 0
    _h = 0
    _data = arr
    
    init
        self._w = w
        self._h = h
        if not self._data: self._data = arrayBuffer(w * h)
    end
    
    function __call(x, y)
        return self._data[(y * self._w) + x]
    end
    
    function set(x, y, val)
        self._data[(y * self._w) + x] = val
        return self
    end
    
    function __get_w(): return self._w
    function __get_h(): return self._h
end

export
